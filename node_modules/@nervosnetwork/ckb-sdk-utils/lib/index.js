"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateMaximumWithdraw = exports.extractDAOData = exports.privateKeyToAddress = exports.privateKeyToPublicKey = exports.rawTransactionToHash = exports.scriptToHash = exports.blake160 = exports.bech32m = exports.bech32 = exports.blake2b = exports.PERSONAL = exports.JSBI = exports.serializeWitnessArgs = exports.serializeTransaction = exports.serializeRawTransaction = exports.serializeScript = exports.reconcilers = exports.systemScripts = void 0;
const tslib_1 = require("tslib");
const jsbi_1 = (0, tslib_1.__importDefault)(require("jsbi"));
exports.JSBI = jsbi_1.default;
const ecpair_1 = (0, tslib_1.__importDefault)(require("./ecpair"));
const convertors_1 = require("./convertors");
const address_1 = require("./address");
const exceptions_1 = require("./exceptions");
const crypto_1 = (0, tslib_1.__importDefault)(require("./crypto"));
const serialization_1 = require("./serialization");
Object.defineProperty(exports, "serializeScript", { enumerable: true, get: function () { return serialization_1.serializeScript; } });
const occupiedCapacity_1 = require("./occupiedCapacity");
const transaction_1 = require("./serialization/transaction");
Object.defineProperty(exports, "serializeRawTransaction", { enumerable: true, get: function () { return transaction_1.serializeRawTransaction; } });
Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function () { return transaction_1.serializeTransaction; } });
Object.defineProperty(exports, "serializeWitnessArgs", { enumerable: true, get: function () { return transaction_1.serializeWitnessArgs; } });
const const_1 = require("./const");
Object.defineProperty(exports, "PERSONAL", { enumerable: true, get: function () { return const_1.PERSONAL; } });
(0, tslib_1.__exportStar)(require("./address"), exports);
(0, tslib_1.__exportStar)(require("./serialization"), exports);
(0, tslib_1.__exportStar)(require("./convertors"), exports);
(0, tslib_1.__exportStar)(require("./epochs"), exports);
(0, tslib_1.__exportStar)(require("./sizes"), exports);
(0, tslib_1.__exportStar)(require("./occupiedCapacity"), exports);
exports.systemScripts = (0, tslib_1.__importStar)(require("./systemScripts"));
exports.reconcilers = (0, tslib_1.__importStar)(require("./reconcilers"));
exports.blake2b = crypto_1.default.blake2b, exports.bech32 = crypto_1.default.bech32, exports.bech32m = crypto_1.default.bech32m, exports.blake160 = crypto_1.default.blake160;
const scriptToHash = (script) => {
    if (!script)
        throw new exceptions_1.ParameterRequiredException('Script');
    const serializedScript = (0, serialization_1.serializeScript)(script);
    const s = (0, exports.blake2b)(32, null, null, const_1.PERSONAL);
    s.update((0, convertors_1.hexToBytes)(serializedScript));
    const digest = s.digest('hex');
    return `0x${digest}`;
};
exports.scriptToHash = scriptToHash;
const rawTransactionToHash = (rawTransaction) => {
    if (!rawTransaction)
        throw new exceptions_1.ParameterRequiredException('Raw transaction');
    const serializedRawTransaction = (0, transaction_1.serializeRawTransaction)(rawTransaction);
    const s = (0, exports.blake2b)(32, null, null, const_1.PERSONAL);
    s.update((0, convertors_1.hexToBytes)(serializedRawTransaction));
    const digest = s.digest('hex');
    return `0x${digest}`;
};
exports.rawTransactionToHash = rawTransactionToHash;
const privateKeyToPublicKey = (privateKey) => {
    const keyPair = new ecpair_1.default(privateKey);
    return keyPair.publicKey;
};
exports.privateKeyToPublicKey = privateKeyToPublicKey;
const privateKeyToAddress = (privateKey, options) => (0, address_1.pubkeyToAddress)((0, exports.privateKeyToPublicKey)(privateKey), options);
exports.privateKeyToAddress = privateKeyToAddress;
const extractDAOData = (dao) => {
    if (!dao.startsWith('0x')) {
        throw new exceptions_1.HexStringWithout0xException(dao);
    }
    const value = dao.replace('0x', '');
    return {
        c: (0, convertors_1.toBigEndian)(`0x${value.slice(0, 16)}`),
        ar: (0, convertors_1.toBigEndian)(`0x${value.slice(16, 32)}`),
        s: (0, convertors_1.toBigEndian)(`0x${value.slice(32, 48)}`),
        u: (0, convertors_1.toBigEndian)(`0x${value.slice(48, 64)}`)
    };
};
exports.extractDAOData = extractDAOData;
const calculateMaximumWithdraw = (outputCell, outputDataCapacity, depositDAO, withdrawDAO) => {
    const depositCellSerialized = (0, occupiedCapacity_1.cellOccupied)(outputCell) + outputDataCapacity.slice(2).length / 2;
    const occupiedCapacity = jsbi_1.default.asUintN(128, jsbi_1.default.multiply(jsbi_1.default.BigInt(100000000), jsbi_1.default.BigInt(depositCellSerialized)));
    return `0x${jsbi_1.default.add(jsbi_1.default.divide(jsbi_1.default.multiply(jsbi_1.default.subtract(jsbi_1.default.asUintN(128, jsbi_1.default.BigInt(outputCell.capacity)), occupiedCapacity), jsbi_1.default.asUintN(128, jsbi_1.default.BigInt((0, exports.extractDAOData)(withdrawDAO).ar))), jsbi_1.default.asUintN(128, jsbi_1.default.BigInt((0, exports.extractDAOData)(depositDAO).ar))), occupiedCapacity).toString(16)}`;
};
exports.calculateMaximumWithdraw = calculateMaximumWithdraw;
//# sourceMappingURL=index.js.map